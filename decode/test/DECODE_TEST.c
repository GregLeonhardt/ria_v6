/*******************************  COPYRIGHT  ********************************/
/**
 *  Author? "Gregory N. Leonhardt"
 *  License? "CC BY-NC 2.0"
 *           "https://creativecommons.org/licenses/by-nc/2.0/"
 *
 ****************************************************************************/

/******************************** JAVADOC ***********************************/
/**
 *  This file contains private functions that makeup the internal
 *  library components of the 'import' library.
 *
 *  @note
 *
 ****************************************************************************/

/****************************************************************************
 *  Compiler directives
 ****************************************************************************/


/****************************************************************************
 * System Function API
 ****************************************************************************/

                                //*******************************************
#include <stdint.h>             //  Alternative storage types
#include <stdbool.h>            //  TRUE, FALSE, etc.
#include <stdio.h>              //  Standard I/O definitions
                                //*******************************************
#include <ctype.h>              //  Determine the type contained
#include <string.h>             //  Functions for managing strings
                                //*******************************************

/****************************************************************************
 * Application APIs
 ****************************************************************************/

                                //*******************************************
#include "global.h"             //  Global stuff for this application
#include "libtools_api.h"       //  My Tools Library
                                //*******************************************
                                //*******************************************
#include "decode_api.h"         //  API for all decode_*            PUBLIC
#include "../decode_lib.h"      //  API for all DECODE__*           PRIVATE
                                //*******************************************

/****************************************************************************
 * Enumerations local to this file
 ****************************************************************************/

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************
 * Definitions local to this file
 ****************************************************************************/

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************
 * Structures local to this file
 ****************************************************************************/

//----------------------------------------------------------------------------
struct  TEST_date_time_s
{
    char                        fmt[ 20 ];
    char                        src[ 50 ];
};

struct  TEST_date_time_s                TEST_date_time_s[ ] =
{
    //  YY MM DD HH MM SS                                   #01
    { "2001-01-02 03:04:05", "2001-01-02 03:04:05"              },  //  00

    //  MM DD YY HH MM   (AP)                               #02
    { "2002-01-01 10:15:00", "1 1 02 10:15"                     },  //  01
    { "2003-01-01 22:15:00", "1 1 03 10:15 PM"                  },  //  02

    //  MM DD YY                                            #03
    { "2004-04-22 00:00:00", "4 22 04"                          },  //  03

    //  DD MON YY HH MM SS                                  #04
    { "2005-01-04 05:04:04", "4 Jan 05 05:04:04"                },  //  04

    //  DOW     DD MON YY HH MM SS AP                       #05
    { "2006-01-01 23:11:11", "Mon 1 Jan 06 11 11 11 PM"         },  //  05

    //  DOW     DD MON YY HH MM    AP                       #06
    { "2007-01-01 23:11:00", "Mon 1 Jan 07 11 11    PM"         },  //  06

    //  DOW     DD MON YY HH MM( SS)                        #07
    { "2008-01-01 11:11:11", "Mon 1 Jan 08 11 11 11"            },  //  07
    { "2009-01-01 11:11:00", "Mon 1 Jan 09 11 11"               },  //  08

    //  DOW MON DD     YY HH MMam                           #08
    { "2010-01-01 11:11:00", "Mon Jan 1 10 11 11AM"             },  //  09

    //  DOW MON DD     YY HH MM                             #09
    { "2011-01-01 11:11:00", "Mon Jan 1 11 11 11"               },  //  10

    //  DOW MON DD        HH MM SS YY                       #10
    { "2012-01-01 11:11:11", "Mon Jan 1 11 11 11 12"            },  //  11

    //  DOW MON DD     YY                                   #11
    { "2013-01-01 00:00:00", "Mon Jan 1 13"                     },  //  12

    //      MON DD     YY HH MM    AP                       #12
    { "2014-01-01 23:11:00", "Jan 1 14 11 11 PM"                },  //  13

    //  MONTH
    { "2005-01-04 05:04:04", "4 Jan 05 05:04:04"                },  //  14
    { "2005-02-04 05:04:04", "4 Feb 05 05:04:04"                },  //  15
    { "2005-03-04 05:04:04", "4 Mar 05 05:04:04"                },  //  16
    { "2005-04-04 05:04:04", "4 APR 05 05:04:04"                },  //  17
    { "2005-05-04 05:04:04", "4 may 05 05:04:04"                },  //  18
    { "2005-06-04 05:04:04", "4 jUn 05 05:04:04"                },  //  19
    { "2005-07-04 05:04:04", "4 JuL 05 05:04:04"                },  //  20
    { "2005-08-04 05:04:04", "4 Aug 05 05:04:04"                },  //  21
    { "2005-09-04 05:04:04", "4 Sep 05 05:04:04"                },  //  22
    { "2005-10-04 05:04:04", "4 Oct 05 05:04:04"                },  //  23
    { "2005-11-04 05:04:04", "4 Nov 05 05:04:04"                },  //  24
    { "2005-12-04 05:04:04", "4 Dec 05 05:04:04"                },  //  25
    { "2005-01-04 05:04:04", "4 January 05 05:04:04"            },  //  26
    { "2005-02-04 05:04:04", "4 February 05 05:04:04"           },  //  27
    { "2005-03-04 05:04:04", "4 March 05 05:04:04"              },  //  28
    { "2005-04-04 05:04:04", "4 APRil 05 05:04:04"              },  //  29
    { "2005-05-04 05:04:04", "4 may 05 05:04:04"                },  //  30
    { "2005-06-04 05:04:04", "4 jUne 05 05:04:04"               },  //  31
    { "2005-07-04 05:04:04", "4 JuLy 05 05:04:04"               },  //  32
    { "2005-08-04 05:04:04", "4 August 05 05:04:04"             },  //  33
    { "2005-09-04 05:04:04", "4 September 05 05:04:04"          },  //  34
    { "2005-10-04 05:04:04", "4 October 05 05:04:04"            },  //  35
    { "2005-11-04 05:04:04", "4 November 05 05:04:04"           },  //  36
    { "2005-12-04 05:04:04", "4 December 05 05:04:04"           },  //  37

    //  Day-Of-Week
    { "2006-01-01 23:11:11", "Mon 1 Jan 06 11 11 11 PM"         },  //  38
    { "2006-01-01 23:11:11", "Tue 1 Jan 06 11 11 11 PM"         },  //  39
    { "2006-01-01 23:11:11", "Wed 1 Jan 06 11 11 11 PM"         },  //  40
    { "2006-01-01 23:11:11", "THU 1 Jan 06 11 11 11 PM"         },  //  41
    { "2006-01-01 23:11:11", "fri 1 Jan 06 11 11 11 PM"         },  //  42
    { "2006-01-01 23:11:11", "sAt 1 Jan 06 11 11 11 PM"         },  //  43
    { "2006-01-01 23:11:11", "SuN 1 Jan 06 11 11 11 PM"         },  //  44
    { "2006-01-01 23:11:11", "Monday 1 Jan 06 11 11 11 PM"      },  //  45
    { "2006-01-01 23:11:11", "Tuesday 1 Jan 06 11 11 11 PM"     },  //  46
    { "2006-01-01 23:11:11", "Wednesday 1 Jan 06 11 11 11 PM"   },  //  47
    { "2006-01-01 23:11:11", "THUrsday 1 Jan 06 11 11 11 PM"    },  //  48
    { "2006-01-01 23:11:11", "Friday 1 Jan 06 11 11 11 PM"      },  //  49
    { "2006-01-01 23:11:11", "sAterday 1 Jan 06 11 11 11 PM"    },  //  50
    { "2006-01-01 23:11:11", "SuNday 1 Jan 06 11 11 11 PM"      },  //  51

    //  AM or PM
    { "2010-01-01 11:11:00", "Mon Jan 1 10 11 11AM"             },  //  52
    { "2010-01-01 23:11:00", "Mon Jan 1 10 11 11PM"             },  //  53
    { "2010-01-01 00:11:00", "Mon Jan 1 10 12 11PM"             },  //  54

    //  Year Adjustment
    { "2008-01-01 11:11:11", "Mon 1 Jan 08 11 11 11"            },  //  55
    { "1998-01-01 11:11:11", "Mon 1 Jan 98 11 11 11"            },  //  56
    { "2008-01-01 11:11:11", "Mon 1 Jan 108 11 11 11"           },  //  57
    { "2008-01-01 11:11:11", "Mon 1 Jan 2008 11 11 11"          },  //  58

    //  Table End
    { "9999-99-99 99:99:99", "9999-99-99 99:99:99"              }   //  END
};
//----------------------------------------------------------------------------

/****************************************************************************
 * Storage Allocation local to this file
 ****************************************************************************/

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************
 * LIB Functions
 ****************************************************************************/

/****************************************************************************/
/**
 *  Unit tests for decode_*
 *
 *  @param  void                No parameters are passed into this function.
 *
 *  @return decode_rc           TRUE if all test pass, else FALSE
 *
 *  @note
 *
 ****************************************************************************/

int
DECODE__TEST_fmt_datetime(
    void
    )
{
    /**
     *  @param  decode_rc       Return code from this function              */
    int                         decode_rc;
    /**
     *  @param  ndx             Index to array                              */
    int                         ndx;
    /**
     *  @param  fmt_datetime_p  Formatted Date / Time string                */
    char                    *   fmt_datetime_p;

    /************************************************************************
     *  Function Initialization
     ************************************************************************/

    //  Initialize variables
    decode_rc = true;

    /************************************************************************
     *  Function Code
     ************************************************************************/

    //  Loop through all test data
    for( ndx = 0;
         strncmp( TEST_date_time_s[ ndx ].src, "9999-99-99 99:99:99", 19 ) != 0;
         ndx += 1 )
    {
        //  DEBUG TRAP
        if ( ndx == 13 )
        {
            log_write( MID_DEBUG_1, "DECODE__TEST", "DEBUG\n" );
        }
        //  Run the sample data through the decoder
        fmt_datetime_p = decode_fmt_datetime( TEST_date_time_s[ ndx ].src );

        //  Verify there is a result string
        if ( fmt_datetime_p == NULL )
        {
            //  ERROR:  Write a message
            log_write( MID_INFO, "DECODE__TEST",
                      "ERROR: 'decode_fmt_datetime( '%s' );' returned a NULL pointer.\n",
                      TEST_date_time_s[ ndx ].fmt,
                      TEST_date_time_s[ ndx ].src );

            //  Set a failed return code
            decode_rc = false;

            //  Stop testing
            break;
        }

        //  Verify the result
        if ( strncmp( fmt_datetime_p, TEST_date_time_s[ ndx ].fmt, 19 ) )
        {
            //  ERROR:  Write a message
            log_write( MID_INFO, "DECODE__TEST",
                      "ERROR: S-%02d '%s' = decode_fmt_datetime( '%s' ); Expected: '%s'\n",
                      ndx,
                      fmt_datetime_p,
                      TEST_date_time_s[ ndx ].src,
                      TEST_date_time_s[ ndx ].fmt );

            //  Set a failed return code
            decode_rc = false;

            //  Stop testing
            break;
        }
    }

    /************************************************************************
     *  Completion Message
     ************************************************************************/

    //  PASS or FAIL ?
    if ( decode_rc == true )
    {
        //  Completion message
        log_write( MID_INFO, "DECODE__TEST", "fmt_datetime\t\t\tPASS\n" );
    }
    else
    {
        //  Completion message
        log_write( MID_INFO, "DECODE__TEST", "fmt_datetime\t\t\tFAIL\n" );
    }

    /************************************************************************
     *  Function Exit
     ************************************************************************/

    // Return the pointer that is set past the amount field
    return ( decode_rc );
}
/****************************************************************************/